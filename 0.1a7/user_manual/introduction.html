

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>A short Introduction &mdash; GraKeL 0.1a7 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/_static/css/supplementary.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A longer Introduction" href="longer_introduction.html" />
    <link rel="prev" title="Installing grakel" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GraKeL
          

          
            
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1a7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../user_manual.html">User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">Installing grakel</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#building-grakel">Building GraKeL</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">A short Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-grakel">What is grakel?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-is-a-graph-kernel">What is a Graph Kernel?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initializing-a-graph-kernel">Initializing a graph kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calculate-a-kernel">Calculate a kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-input-type">The input type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fitting-on-a-dataset">Fitting on a dataset</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="longer_introduction.html">A longer Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="make_your_own_kernel.html">Write your own kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">GraKeL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GraKeL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../user_manual.html">User Manual</a> &raquo;</li>
        
      <li>A short Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_manual/introduction.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="introduction"></span><div class="section" id="a-short-introduction">
<h1>A short Introduction<a class="headerlink" href="#a-short-introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-is-grakel">
<h2>What is grakel?<a class="headerlink" href="#what-is-grakel" title="Permalink to this headline">¶</a></h2>
<p>GraKeL is a library for the study, use and integration of an upcoming collection
of techniques, inside the field of Machine Learning known as graph kernels. These
techniques utilize information derived from a conceived structure of the data, in
order to apply conventional machine learning techniques for achieving tasks as
classification, ranking, etc. Graph Kernels have been widely used in fields such
as chemistry, bio-informatics, social networks and malware detection and are starting
to be considered as the state-of-the-art solution for various problems inside the field of ML.</p>
</div>
<div class="section" id="what-is-a-graph-kernel">
<h2>What is a Graph Kernel?<a class="headerlink" href="#what-is-a-graph-kernel" title="Permalink to this headline">¶</a></h2>
<p>A graph kernel is a measure of similarity between two graphs, that obeys a certain
mathematical constraint, which is <em>that the calculation of each similarity measure between two graphs implies a representation of this two graphs in a</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Hilbert_space">hilbert space</a>, where those to graphs are represented as vectors. This can be notated as the
following:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}k \; : \; \mathcal{G} \times \mathcal{G} \rightarrow \mathbb{R} \text{ is a
valid kernel, if there exists a map } \phi \; :\; \mathcal{G} \rightarrow
\mathbb{H}, \\\text{for a Hilbert space } \mathbb{H} \text{ where each kernel
value can be computed as }\\ k(G_{i}, G_{j}) = \langle G_{i}, G_{j} \rangle
\text{ where } \langle \;.\; ,\; .\;\rangle \text{ signifies an inner product inside this space}.\end{split}\]</div>
</div></blockquote>
<p>The above definition is satisfied in the literature, by proving that the produced kernel matrix from any collection of graphs <span class="math notranslate nohighlight">\(\{G_{i}, \text{for } i\in [N]\}\)</span>, where <span class="math notranslate nohighlight">\([K]_{ij} = k(G_{i}, G_{j})\)</span>, is <a class="reference external" href="https://en.wikipedia.org/wiki/Positive-definite_matrix">Positive Semi Definite</a>.</p>
</div>
<div class="section" id="initializing-a-graph-kernel">
<h2>Initializing a graph kernel<a class="headerlink" href="#initializing-a-graph-kernel" title="Permalink to this headline">¶</a></h2>
<p>A very well known graph kernel found in literature is the Shortest Path Kernel first introduced by Karsten M. Borgwardt
and Hans-Peter Kriegel on a 2005 article [see [Borgwardt2005ShortestpathKO]] titled <strong>“Shortest-Path Kernels on Graphs”</strong>,
really essential as an origin of the Graph Kernel field.</p>
<p>After following the instructions found on <a class="reference internal" href="installation.html#installation"><span class="std std-ref">Installing grakel</span></a>, in order to initialize a <em>Shortest Path</em> kernel
using the <strong>grakel</strong> library, you just need to do the following:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;shortest_path&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Kernels as the above are considered as <em>base kernels</em>, meaning that they can be computed onto the sets
of Graphs needed only a minor parametrization. A second type of kernels appear in the literature which
we will call <em>meta-kernels</em>, which apply transformation operations upon graph objects in order to apply
kernel calculations on certain steps using a <em>base kernel</em>, aggregating their result in a certain way.
A kernel like <em>Weisfeiler-Lehman</em> introduced by Nino Shervashidze at 2011, published on a journal with the title
“Weisfeiler Lehman Kernels” [see [Shervashidze2011WeisfeilerLehmanGK]], used a method for approximating a
solution to the graph isomorphism problem, in order to generate a graph refinement scheme that would imply
bigger expressiveness to the base_kernel calculations (an interesting <a class="reference external" href="http://blog.smola.org/post/33412570425/the-weisfeiler-lehman-algorithm-and-estimation-on">post</a> explaining the intuition of this kernel).</p>
<p>To initialize such a kernel, using the default subtree kernel, found originally on the paper’s
page 9, eq. 2, you can do the following:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="calculate-a-kernel">
<h2>Calculate a kernel<a class="headerlink" href="#calculate-a-kernel" title="Permalink to this headline">¶</a></h2>
<p>Let’s consider a toy example, comparing water <span class="math notranslate nohighlight">\(\mathbf{H}_{2}\mathbf{O}\)</span> with hydronium
<span class="math notranslate nohighlight">\(\mathbf{H}_{3}\mathbf{O}^{+}\)</span>, an ion of water produced by protonation.</p>
<p>For start we would calculate the kernel value of water with itself:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="go">array([[12.]])</span>
</pre></div>
</div>
<p>Now to calculate the graph similarity to hydronium based on the shortest path
graph kernel</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">}]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">array([[24.]])</span>
</pre></div>
</div>
<p>This result seems like the water molecule is more similar to hydronium, than with itself.
This is a false assumption derived from the fact that the kernel calculation is not normalized.</p>
<p>To apply normalization we add such an argument on the GraphKernel method
initialization and continue</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;shortest_path&quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="go">array([[1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">array([[0.94280904]])</span>
</pre></div>
</div>
</div>
<div class="section" id="the-input-type">
<h2>The input type<a class="headerlink" href="#the-input-type" title="Permalink to this headline">¶</a></h2>
<p>On the above example concerning water and hydronium, we provided a very strange input object
without saying anything about it. The input concerns the user mostly when dealing with an
API, so we will examine it in detail although this is a small introduction.</p>
<p>The input of any kernel - either on the stage of fit or of transform - (to learn more about the
kernel design see <a class="reference internal" href="longer_introduction.html#longer-introduction"><span class="std std-ref">A longer Introduction</span></a>) is an iterable, where each element
contains in following order, the next 3 basic elements:</p>
<ol class="arabic">
<li><p class="first">The first element is a valid graph object. Valid graph objects can be separated in two major categories (both <span class="red">weighted</span> and <span class="blue">un-weighted</span>):</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>Dictionary representations: This is an <em>edge</em> oriented approach, where the input can have one of the following formats:</dt>
<dd><ul class="first last">
<li><div class="first line-block">
<div class="line"><span class="red">2-level nested dictionaries from edge symbols to weights.</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">{'a':</span> <span class="pre">{'b':</span> <span class="pre">1.,</span> <span class="pre">'c':</span> <span class="pre">1.},</span> <span class="pre">'b':</span> <span class="pre">{'a':</span> <span class="pre">1},</span> <span class="pre">'c':</span> <span class="pre">{'a':</span> <span class="pre">1.}}</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><span class="blue">Dictionary of symbols to list of symbols.</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">{'a':</span> <span class="pre">['b',</span> <span class="pre">'c'],</span> <span class="pre">'b':</span> <span class="pre">['a'],</span> <span class="pre">'c':</span> <span class="pre">['b']}</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><span class="red">Dictionary of tuples to weights.</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">{('a',</span> <span class="pre">'b'):</span> <span class="pre">1.,</span> <span class="pre">('a',</span> <span class="pre">'c'):</span> <span class="pre">1.,</span> <span class="pre">('c',</span> <span class="pre">'a'):</span> <span class="pre">1.,</span> <span class="pre">('b',</span> <span class="pre">'a'):</span> <span class="pre">1.}</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><span class="blue">Iterable of tuples of lenght 2.</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">[('a',</span> <span class="pre">'b'),</span> <span class="pre">('a',</span> <span class="pre">'c'),</span> <span class="pre">('b',</span> <span class="pre">'a'),</span> <span class="pre">('c',</span> <span class="pre">'a')]</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><span class="blue">Iterable of tuples of length 3.</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">[('a',</span> <span class="pre">'b',</span> <span class="pre">1.),</span> <span class="pre">('a',</span> <span class="pre">'c',</span> <span class="pre">1.),</span> <span class="pre">('b',</span> <span class="pre">'a',</span> <span class="pre">1.),</span> <span class="pre">('c',</span> <span class="pre">'a',</span> <span class="pre">1.)]</span></code></div>
</div>
</li>
</ul>
</dd>
</dl>
<p>As seen above all the graph objects are considered <strong>directed</strong> graphs.</p>
</li>
<li><p class="first">Array representations: This is a <em>vertex</em> oriented approach, where the input can have on of the following formats:</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line"><span class="red">array-like lists of lists</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">[[0,</span> <span class="pre">1,</span> <span class="pre">1],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]]</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><span class="red">np.array</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">numpy.array([[0,</span> <span class="pre">1,</span> <span class="pre">1],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]])</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><span class="red">sparse matrix (scipy.sparse)</span></div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O</span> <span class="pre">=</span> <span class="pre">scipy.sparse.csr_matrix(([1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1],</span> <span class="pre">([0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2],</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">0])),</span> <span class="pre">shape=(3,</span> <span class="pre">3))</span></code></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The second <em>optional</em> element is a graph labeling of vertices (or nodes):</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">Dictionary representations: Dictionary between vertex symbols and label symbols.</div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O_labels</span> <span class="pre">=</span> <span class="pre">{'a':</span> <span class="pre">'O',</span> <span class="pre">'b':</span> <span class="pre">'H',</span> <span class="pre">'c':</span> <span class="pre">'H'}</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Array representations: Dictionary between numbers with int keys from <span class="math notranslate nohighlight">\(0 \cdots |V|-1\)</span> to label symbols.</div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O_labels</span> <span class="pre">=</span> <span class="pre">{0:</span> <span class="pre">'O',</span> <span class="pre">1:</span> <span class="pre">'H',</span> <span class="pre">2:'H'}</span></code></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Normally in the literature <em>labels</em> correspond to scalars or single symbols and not to vector-like objects, which are defined as <em>attributes</em>.
As far as the input representation is concerned the second object is either labels or attributes for graph <strong>vertices</strong> and the distinction
between attributed kernels or labeled once is specified for each kernel. Here we have made the assumption that never a kernel uses both labels
or attributes for <em>vertices</em> and if it does so, a label representation can be applied such that the kernel can use only the one kind of labels.</p>
</div>
</div></blockquote>
</li>
<li><p class="first">The third <em>optional</em> element is a graph labeling of edges:</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">Dictionary representations: Dictionary between tuples of vertex symbols for all edges and label symbols.</div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O_edge_labels</span> <span class="pre">=</span> <span class="pre">{('a',</span> <span class="pre">'b'):</span> <span class="pre">'pcb',</span> <span class="pre">('b',</span> <span class="pre">'a'):</span> <span class="pre">'pcb',</span> <span class="pre">('a',</span> <span class="pre">'c'):</span> <span class="pre">'pcb',</span> <span class="pre">('c',</span> <span class="pre">'a'):</span> <span class="pre">'pcb'}</span></code></div>
</div>
</li>
<li><div class="first line-block">
<div class="line">Array representations: Dictionary between numbers tuples of int keys from <span class="math notranslate nohighlight">\(0 \cdots |V|-1\)</span> for all matrix entries considered as edges and label symbols.</div>
<div class="line">Example: <code class="code docutils literal notranslate"><span class="pre">H2O_edge_labels</span> <span class="pre">=</span> <span class="pre">{(0,</span> <span class="pre">1):</span> <span class="pre">'pcb',</span> <span class="pre">(1,</span> <span class="pre">0):</span> <span class="pre">'pcb',</span> <span class="pre">(0,</span> <span class="pre">2):</span> <span class="pre">'pcb',</span> <span class="pre">(2,</span> <span class="pre">0):</span> <span class="pre">'pcb'}</span></code></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As soon as the same unification of node labels and attributes is valid, a second distinction should be made here.
Labels between edges are not weight values. This means that if the user wants to apply such approach to a kernel, that uses weight values in such a way as the
Random Walk Kernel, she/he should enrich the graph-type input with weights between all edges that correspond to the edge-labels he/she is intended to use.</p>
</div>
</div></blockquote>
</li>
</ol>
<p>As defined above the input should be an iterable of any iterable producing at most one and at least three (or more for certain kernels elements).
To signify absence of node labels if the elements produced by each iterable are more than 2 or edge labels if the labels produced are more than 3
the user can provide the empty list or a None Object.</p>
</div>
<div class="section" id="fitting-on-a-dataset">
<h2>Fitting on a dataset<a class="headerlink" href="#fitting-on-a-dataset" title="Permalink to this headline">¶</a></h2>
<p>The next important step and final for our short introduction is to see how to apply a kernel on dataset of graphs and labels.</p>
<p>To do so we will utilize the <code class="code docutils literal notranslate"><span class="pre">fetch_dataset</span></code> function found on <a class="reference internal" href="../datasets.html#datasets"><span class="std std-ref">Dataset loading utilities</span></a>.
Firstly download the dataset:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span><span class="p">,</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG_data</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
<p>Note that the <code class="code docutils literal notranslate"><span class="pre">fetch_dataset</span></code> function returns a sklearn.utils.Bunch object, where
the graph-data can be found in the data class member of the result.</p>
<p>Now let’s initialize a Weisfeiler-Lehman Kernel with 5 iterations:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s split the dataset in a train/test manner and calculate fit on the train set.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">split_point</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MUTAG_data</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="n">MUTAG_data</span><span class="p">[:</span><span class="n">split_point</span><span class="p">],</span> <span class="n">MUTAG_data</span><span class="p">[</span><span class="n">split_point</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to apply classification on a dataset based on the calculation of a kernel matrix, one generally needs
the matrix between all the training data. Namely given <span class="math notranslate nohighlight">\(\mathcal{G}^{\text{train}}\)</span> a collection of graphs, calculate
the kernel values with a function <span class="math notranslate nohighlight">\(\mathcal{K}: \mathcal{G}^{\text{train}} \rightarrow \mathbb{R}^{n_{\text{train}}} \times \mathbb{R}^{n_{\text{train}}}\)</span>,
where <span class="math notranslate nohighlight">\(n_{\text{train}}\)</span> is the number of graphs inside the training set. This function that simply outputs the kernel
matrix between all graphs of the graphs of the training set is equivalent with</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">wl_kernel</span></code> is now fitted with the train data and we would like given a collection of graphs <span class="math notranslate nohighlight">\(\mathcal{G}^{\text{test}}\)</span>
to calculate all the kernel values with a function <span class="math notranslate nohighlight">\(\mathcal{K}: \mathcal{G}^{\text{train}} \times \mathcal{G}^{\text{test}} \rightarrow \mathbb{R}^{n_{\text{test}}} \times \mathbb{R}^{n_{\text{train}}}\)</span> where <span class="math notranslate nohighlight">\(n_{\text{test}}\)</span> is the number of graphs inside the test set. This function can be calculated as:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>
</div>
<p>which is equivalent to calculating:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>
</div>
<p>except the case where the kernel is not deterministic and aside the fact that fitting in the most
cases takes the majority of the overall kernel computation time.</p>
<p>Finally to demonstrate a classification task using a standard SVM, with a precomputed kernel
(a very well known process in the field’s literature) we first take the targets (which are the
class labels) as follows:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">split_point</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">split_point</span><span class="p">:]</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">import</span></code> and initialize a sk-learn <code class="code docutils literal notranslate"><span class="pre">SVC</span></code></p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>classify</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">K_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,</span>
<span class="go">  decision_function_shape=&#39;ovr&#39;, degree=3, gamma=&#39;auto&#39;,</span>
<span class="go">  kernel=&#39;precomputed&#39;, max_iter=-1, probability=False, random_state=None,</span>
<span class="go">  shrinking=True, tol=0.001, verbose=False)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">K_test</span><span class="p">)</span>
</pre></div>
</div>
<p>and print the accuracy score</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%2.2f</span><span class="s2"> </span><span class="si">%%</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)))</span>
<span class="go">79.00 %</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="longer_introduction.html" class="btn btn-neutral float-right" title="A longer Introduction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installation.html" class="btn btn-neutral float-left" title="Installing grakel" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, DaSciM (BSD License)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>